import os
import numpy as np
import re
import pickle

ALLOWED_EXTENSIONS = set(['smali'])


def allowed_file(filename):
	return '.' in filename and filename.rsplit('.', 1)[1] in ALLOWED_EXTENSIONS


class ApiFeatureExtract:
	def __init__(self, path):
		self.path = path  # 反编译后的apps目录
		self.app = dict()  # 应用编号，便于管理 app->No.
		self.app2api = dict()  # 每个应用的api集合 appNo->api
		self.api_coding = dict()  # api编号，便于管理  api->No.

	def run(self):
		ben_app_num = self.__find_all_smali("ben_code/")
		mal_app_num = self.__find_all_smali("mal_code/")
		api_feature_matrix = self.__feature_matrix()
		classification = np.ones((ben_app_num + mal_app_num,), dtype=np.int)  # 分类结果
		for i in range(ben_app_num):
			classification[i] = 0
		pickle.dump(api_feature_matrix, open('dataset/api_feature_matrix', 'wb'))  # 固化特征矩阵
		pickle.dump(classification, open('dataset/classification', 'wb'))  # 固化分类结果
		pickle.dump(self.api_coding, open('dataset/api_coding', 'wb'))  # 固化api编号
		pass

	def __find_all_smali(self, relative_path):
		"""找到目录中所有的smali文件
		"""
		count0 = count = len(self.app)
		cur_path = os.path.join(self.path, relative_path)
		for files in os.listdir(cur_path):
			smali_path = os.path.join(cur_path, files + '/smali/')
			if os.path.exists(smali_path):
				print('Analyzing path:',smali_path,'Total app analyzed:',count)
				self.app[files] = count
				self.app2api[count] = dict()
				for path1 in os.listdir(smali_path):
					if path1 != 'android':
						stack = list()
						full_path = os.path.join(smali_path, path1)
						if os.path.isdir(full_path):
							stack.append(full_path)
						elif allowed_file(full_path):
							# smali文件
							self.__regular(full_path, count)
						# dfs
						while len(stack) > 0:
							tmp = stack.pop()
							for path in os.listdir(tmp):
								next_path = os.path.join(tmp, path)
								if os.path.isdir(next_path):
									stack.append(next_path)
								elif allowed_file(next_path):
									# smali文件
									self.__regular(next_path, count)
				count += 1
		return count - count0

	def __regular(self, file_path, count):
		f = open(file_path, 'r')
		content = f.read()
		str_list = re.findall('invoke[^\n]*Landroid[^\n]*->[^\n]*', content)
		for item in str_list:
			#  lib
			start = item.find('Landroid')
			end = item.find('->')
			lib_name = item[start + 1:end - 1]
			lib_name = lib_name.replace('/', '.')
			lib_name = lib_name.replace('$', '.')
			func_name = re.search('->\w+\(', item[end::])
			if func_name:
				func_name = func_name.group()[2:-1] + '()'
				api = lib_name + '->' + func_name
				if self.app2api[count].get(api) is None:
					self.app2api[count][api] = 0
				else:
					self.app2api[count][api] += 1
				# api编号
				if self.api_coding.get(api) is None:
					self.api_coding[api] = len(self.api_coding)
		f.close()

	def __feature_matrix(self):
		"""构建特征矩阵
		"""
		matrix = np.zeros(shape=(len(self.app), len(self.api_coding)))  # 特征矩阵，目测是稀疏矩阵，暂时使用numpy array
		for i in range(len(self.app)):
			for api in self.app2api[i]:
				j = self.api_coding[api]  # api编号
				# matrix[i][j] = self.app2api[i][api]  #使用调用次数当作权重
				matrix[i][j] = 1  # 使用0-1当作权重
		return matrix
